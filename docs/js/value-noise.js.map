{"version":3,"sources":["webpack://ValueNoise/webpack/universalModuleDefinition","webpack://ValueNoise/webpack/bootstrap","webpack://ValueNoise/./src/helpers/PRNG.js","webpack://ValueNoise/./src/ValueNoise.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","PRNG","seed","this","min","max","next","ValueNoise","settings","options","assign","Math","random","wavelength","amplitude","width","height","depth","dimension","octaves","octaveIndex","wavelengthx","wavelengthy","wavelengthz","randomise","interpolate","quadratic","pa","pb","px","ft","PI","f","cos","rand","rows","Array","fill","map","generate","x","y","normalisedX","normalisedY","currentNodeX","nextNodeX","currentNodeY","nextNodeY","z","normalisedZ","currentNodeZ","nextNodeZ","ret","offset","add","gen2d","pixel","gen3d"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAoB,WAAID,IAExBD,EAAiB,WAAIC,IARvB,CASGK,QAAQ,WACX,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUP,QAGnC,IAAIC,EAASI,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHT,QAAS,IAUV,OANAU,EAAQH,GAAUI,KAAKV,EAAOD,QAASC,EAAQA,EAAOD,QAASM,GAG/DL,EAAOQ,GAAI,EAGJR,EAAOD,QA0Df,OArDAM,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASd,EAASe,EAAMC,GAC3CV,EAAoBW,EAAEjB,EAASe,IAClCG,OAAOC,eAAenB,EAASe,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAStB,GACX,oBAAXuB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAenB,EAASuB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAenB,EAAS,aAAc,CAAEyB,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAAShC,GAChC,IAAIe,EAASf,GAAUA,EAAO2B,WAC7B,WAAwB,OAAO3B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAK,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,UAIjBhC,EAAoBA,EAAoBiC,EAAI,G,gNC5EhCC,E,WACnB,aAAsB,IAAVC,EAAU,uDAAH,G,4FAAG,SACpBC,KAAKD,KAAOA,EAAO,WACfC,KAAKD,MAAQ,IAAKC,KAAKD,MAAQ,Y,sDAQnC,OADAC,KAAKD,KAAmB,MAAZC,KAAKD,KAAe,WACzBC,KAAKD,O,iCAMa,IAAlBE,EAAkB,uDAAZ,EAAGC,EAAS,uDAAH,EAEtB,OAAOD,GAAQD,KAAKG,OAAS,GAAK,YAAeD,EAAMD,Q,kPCtBtCG,E,WAMnB,aAA2B,IAAfC,EAAe,uDAAJ,I,4FAAI,SACzB,IAAMC,EAAU9B,OAAO+B,OAAO,CAC5BR,QAASS,KAAKC,SAALD,KAAA,IAAgB,EAAK,KAC9BE,WAAY,GACZC,UAAW,EACXC,MAAO,GACPC,OAAQ,GACRC,MAAO,GACPC,UAAW,EACXC,QAAS,EACTC,YAAa,GACZZ,GAEH7B,OAAO+B,OAAOP,KAAMM,GAEpBN,KAAKkB,YAAcZ,EAAQI,WAC3BV,KAAKmB,YAAcb,EAAQI,WAC3BV,KAAKoB,YAAcd,EAAQI,WAE3BV,KAAKqB,UAAUrB,KAAKD,MAEpBC,KAAKsB,YAActB,KAAKuB,U,sDAGnBC,EAAIC,EAAIC,GACb,IAAMC,EAAKD,EAAKlB,KAAKoB,GACfC,EAAyB,IAApB,EAAIrB,KAAKsB,IAAIH,IACxB,OAAOH,GAAM,EAAIK,GAAKJ,EAAKI,I,4BAGvBL,EAAIC,EAAIC,GACZ,OAAIA,EAAK,GAAY,EAAI,KAAJ,IAAIA,EAAM,IAAKD,EAAKD,GAAMA,IACtCE,EAAK,IAAM,EAAIA,EAAK,IAAM,EAAIA,EAAK,GAAK,IAAMD,EAAKD,GAAMA,I,gCAS1DA,EAAIC,EAAIC,GAChB,OAAOA,EAAK,GAAM,EAAI,KAAJ,IAAIA,EAAM,IAAKD,EAAKD,GAAMA,IAAY,EAAI,EAAIE,GAAMA,EAAnB,IAA0BD,EAAKD,GAAMA,I,6BASnFA,EAAIC,EAAIC,GACb,OAAOF,GAAMC,EAAKD,GAAME,I,kCAM0B,WAA1C3B,EAA0C,0DAAhCS,KAAKC,UAAY,WAAK,IAAK,IACvCsB,EAAO,IAAIjC,EAAKC,GAChB3B,EAAI4B,KAAKe,UAEff,KAAKgC,KAAOC,MAAMjC,KAAKa,QAAQqB,KAAK,GAAGC,KACrC,WACE,OAAI/D,EAAI,EACC6D,MAAM,EAAKrB,OAAOsB,KAAK,GAAGC,KAAI,WACnC,OAAI/D,EAAI,EACC6D,MAAM,EAAKnB,OAAOoB,KAAK,GAAGC,KAAI,kBAAMJ,EAAKK,WAAa,EAAKzB,aAE7DoB,EAAKK,WAAa,EAAKzB,aAG3BoB,EAAKK,WAAa,EAAKzB,e,4BAU9B0B,EAAGC,EAAGpB,EAAaC,GAGvB,IAAMoB,EAAcF,EAAKrC,KAAKY,MAAQM,EAAe,EAAImB,GAAMrC,KAAKY,MAASM,GAAemB,EACtFG,EAAcF,EAAKtC,KAAKa,OAASM,EAAe,EAAImB,GAAMtC,KAAKa,OAAUM,GAAemB,EAGxFG,KAAkBF,EAAcrB,GAChCwB,EAA4C,KAA7BH,EAAcrB,GAAmBlB,KAAKY,MACvB,KAA7B2B,EAAcrB,GACjB,EACEyB,KAAkBH,EAAcrB,GAChCyB,EAA4C,KAA7BJ,EAAcrB,GAAmBnB,KAAKa,OACvB,KAA7B2B,EAAcrB,GACjB,EAGJ,OAAImB,EAAInB,GAAgB,EAElBkB,EAAInB,GAAgB,EACflB,KAAKgC,KAAKW,GAAcF,GAG1BzC,KAAKsB,YACVtB,KAAKgC,KAAKW,GAAcF,GACxBzC,KAAKgC,KAAKW,GAAcD,GACvBL,EAAInB,EAAeA,GAIpBmB,EAAInB,GAAgB,EAEflB,KAAKsB,YACVtB,KAAKgC,KAAKW,GAAcF,GACxBzC,KAAKgC,KAAKY,GAAWH,GACpBH,EAAInB,EAAeA,GAIjBnB,KAAKsB,YACVtB,KAAKsB,YACHtB,KAAKgC,KAAKW,GAAcF,GACxBzC,KAAKgC,KAAKY,GAAWH,GACpBH,EAAInB,EAAeA,GAEtBnB,KAAKsB,YACHtB,KAAKgC,KAAKW,GAAcD,GACxB1C,KAAKgC,KAAKY,GAAWF,GACpBJ,EAAInB,EAAeA,GAErBkB,EAAInB,EAAeA,K,4BAUlBmB,EAAGC,EAAGO,EAAG3B,EAAaC,EAAaC,GAIvC,IAAMmB,EAAcF,EAAKrC,KAAKY,MAAQM,EAAe,EAAImB,GAAMrC,KAAKY,MAASM,GAAemB,EACtFG,EAAcF,EAAKtC,KAAKa,OAASM,EAAe,EAAImB,GAAMtC,KAAKa,OAAUM,GAAemB,EACxFQ,EAAcD,EAAK7C,KAAKa,OAASO,EAAe,EAAIyB,GAAM7C,KAAKa,OAAUO,GAAeyB,EAGxFJ,KAAkBF,EAAcrB,GAChCwB,EAA4C,KAA7BH,EAAcrB,GAAmBlB,KAAKY,MACvB,KAA7B2B,EAAcrB,GACjB,EACEyB,KAAkBH,EAAcrB,GAChCyB,EAA4C,KAA7BJ,EAAcrB,GAAmBnB,KAAKa,OACvB,KAA7B2B,EAAcrB,GACjB,EACE4B,KAAkBD,EAAc1B,GAChC4B,EAA4C,KAA7BF,EAAc1B,GAAmBpB,KAAKc,MACvB,KAA7BgC,EAAc1B,GACjB,EAGJ,OAAIyB,EAAIzB,GAAgB,EAElBkB,EAAInB,GAAgB,EAElBkB,EAAInB,GAAgB,EACflB,KAAKgC,KAAKW,GAAcF,GAAcM,GAIxC/C,KAAKsB,YACVtB,KAAKgC,KAAKW,GAAcF,GAAcM,GACtC/C,KAAKgC,KAAKW,GAAcD,GAAWK,GAClCV,EAAInB,EAAeA,GAKpBmB,EAAInB,GAAgB,EAEflB,KAAKsB,YACVtB,KAAKgC,KAAKW,GAAcF,GAAcM,GACtC/C,KAAKgC,KAAKY,GAAWH,GAAcM,GAClCT,EAAInB,EAAeA,GAKjBnB,KAAKsB,YAEVtB,KAAKsB,YACHtB,KAAKgC,KAAKW,GAAcF,GAAcM,GACtC/C,KAAKgC,KAAKY,GAAWH,GAAcM,GAClCT,EAAInB,EAAeA,GAGtBnB,KAAKsB,YACHtB,KAAKgC,KAAKW,GAAcD,GAAWK,GACnC/C,KAAKgC,KAAKY,GAAWF,GAAWK,GAC/BT,EAAInB,EAAeA,GAGrBkB,EAAInB,EAAeA,GAQpBoB,EAAInB,GAAgB,EAElBkB,EAAInB,GAAgB,EACflB,KAAKsB,YACVtB,KAAKgC,KAAKW,GAAcF,GAAcM,GACtC/C,KAAKgC,KAAKW,GAAcF,GAAcO,GACrCH,EAAIzB,EAAeA,GAIjBpB,KAAKsB,YAEVtB,KAAKsB,YACHtB,KAAKgC,KAAKW,GAAcF,GAAcM,GACtC/C,KAAKgC,KAAKW,GAAcD,GAAWK,GAClCV,EAAInB,EAAeA,GAGtBlB,KAAKsB,YACHtB,KAAKgC,KAAKW,GAAcF,GAAcO,GACtChD,KAAKgC,KAAKW,GAAcD,GAAWM,GAClCX,EAAInB,EAAeA,GAGrB2B,EAAIzB,EAAeA,GAIpBiB,EAAInB,GAAgB,EAEflB,KAAKsB,YACVtB,KAAKsB,YACHtB,KAAKgC,KAAKW,GAAcF,GAAcM,GACtC/C,KAAKgC,KAAKY,GAAWH,GAAcM,GAClCT,EAAInB,EAAeA,GAGtBnB,KAAKsB,YACHtB,KAAKgC,KAAKW,GAAcF,GAAcO,GACtChD,KAAKgC,KAAKY,GAAWH,GAAcO,GAClCV,EAAInB,EAAeA,GAGrB0B,EAAIzB,EAAeA,GAIjBpB,KAAKsB,YAEVtB,KAAKsB,YACHtB,KAAKsB,YACHtB,KAAKgC,KAAKW,GAAcF,GAAcM,GACtC/C,KAAKgC,KAAKY,GAAWH,GAAcM,GAClCT,EAAInB,EAAeA,GAEtBnB,KAAKsB,YACHtB,KAAKgC,KAAKW,GAAcD,GAAWK,GACnC/C,KAAKgC,KAAKY,GAAWF,GAAWK,GAC/BT,EAAInB,EAAeA,GAErBkB,EAAInB,EAAeA,GAGtBlB,KAAKsB,YACHtB,KAAKsB,YACHtB,KAAKgC,KAAKW,GAAcF,GAAcO,GACtChD,KAAKgC,KAAKY,GAAWH,GAAcO,GAClCV,EAAInB,EAAeA,GAEtBnB,KAAKsB,YACHtB,KAAKgC,KAAKW,GAAcD,GAAWM,GACnChD,KAAKgC,KAAKY,GAAWF,GAAWM,GAC/BV,EAAInB,EAAeA,GAErBkB,EAAInB,EAAeA,GAGrB2B,EAAIzB,EAAeA,K,iCActB,IALqB,IAAdiB,EAAc,uDAAV,EAAGC,EAAO,uDAAH,EACdW,EAAM,EACNC,EAAS,EAGJpF,EAAI,EAAGA,EAAIkC,KAAKgB,QAASlD,IAAK,CACrC,IAAM6C,EAAYX,KAAKW,UAAL,SAAiBX,KAAKiB,YAAenD,GACjDoD,EAAcV,KAAKN,IAAIF,KAAKkB,YAAL,SAAmBlB,KAAKiB,YAAenD,GAAG,GACjEqD,EAAcX,KAAKN,IAAIF,KAAKmB,YAAL,SAAmBnB,KAAKiB,YAAenD,GAAG,GAEjEqF,EAAMnD,KAAKoD,MAAMf,EAAGC,EAAGpB,EAAaC,GAAeR,EAEzDsC,GAAOE,EACPD,GAAU,EAAI,KAAJ,IAAIlD,KAAKiB,YAAenD,GAIpC,OAAOmF,EAAMC,I,mCAQb,IALyC,IAAhCb,EAAgC,uDAA5B,EAAGC,EAAyB,uDAArB,EAAGO,EAAkB,uDAAd,EAAGQ,EAAW,uDAAH,EAClCJ,EAAM,EACNC,EAAS,EAGJpF,EAAI,EAAGA,EAAIkC,KAAKgB,QAASlD,IAAK,CACrC,IAAM6C,EAAYX,KAAKW,UAAL,SAAiBX,KAAKiB,YAAenD,GACjDoD,EAAcV,KAAKN,IAAIF,KAAKkB,YAAL,SAAmBlB,KAAKiB,YAAenD,GAAG,GACjEqD,EAAcX,KAAKN,IAAIF,KAAKmB,YAAL,SAAmBnB,KAAKiB,YAAenD,GAAG,GACjEsD,EAAcZ,KAAKN,IAAIF,KAAKoB,YAAL,SAAmBpB,KAAKiB,YAAenD,GAAG,GAEvEmF,GAAOjD,KAAKsD,MAAMjB,EAAGC,EAAGO,EAAG3B,EAAaC,EAAaC,EAAciC,EAAQ,EAAG,GAAK1C,EACnFuC,GAAU,EAAI,KAAJ,IAAIlD,KAAKiB,YAAenD,GAGpC,OAAOmF,EAAMC,O","file":"value-noise.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ValueNoise\"] = factory();\n\telse\n\t\troot[\"ValueNoise\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"docs/js\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\r\n * Creates a pseudo-random value generator. The seed must be an integer.\r\n *\r\n * Uses an optimized version of the Park-Miller PRNG.\r\n * http://www.firstpr.com.au/dsp/rand31/\r\n */\r\nexport default class PRNG {\r\n  constructor(seed = 0) {\r\n    this.seed = seed % 2147483647;\r\n    if (this.seed <= 0) { this.seed += 2147483646; }\r\n  }\r\n\r\n  /**\r\n   * Returns a pseudo-random value between 1 and 2^32 - 2.\r\n   */\r\n  next() {\r\n    this.seed = this.seed * 16807 % 2147483647;\r\n    return this.seed;\r\n  }\r\n\r\n  /**\r\n   * Returns a pseudo-random floating point number in range [0, 1).\r\n   */\r\n  generate(min = 0, max = 1) {\r\n    // We know that result of next() will be 1 to 2147483646 (inclusive).\r\n    return min + ((this.next() - 1) / 2147483646) * (max - min);\r\n  }\r\n}\r\n","import PRNG from './helpers/PRNG';\n\n\nexport default class ValueNoise {\n  /**\n   * ValueNoise object\n   * @param {number} wavelength space between noise nodes\n   * @param {number} amplitude max value of output\n   */\n  constructor(settings = {}) {\n    const options = Object.assign({\n      seed: ~~(Math.random() * 2 ** 31),\n      wavelength: 20,\n      amplitude: 1,\n      width: 50,\n      height: 50,\n      depth: 50,\n      dimension: 2,\n      octaves: 5,\n      octaveIndex: 2,\n    }, settings);\n\n    Object.assign(this, options);\n\n    this.wavelengthx = options.wavelength;\n    this.wavelengthy = options.wavelength;\n    this.wavelengthz = options.wavelength;\n\n    this.randomise(this.seed);\n\n    this.interpolate = this.quadratic;\n  }\n\n  cosine(pa, pb, px) {\n    const ft = px * Math.PI;\n    const f = (1 - Math.cos(ft)) * 0.5;\n    return pa * (1 - f) + pb * f;\n  }\n\n  cubic(pa, pb, px) {\n    if (px < 0.5) return 4 * px ** 3 * (pb - pa) + pa;\n    return ((px - 1) * (2 * px - 2) * (2 * px - 2) + 1) * (pb - pa) + pa;\n  }\n\n  /**\n   * Quadratically interpolates between points a and b\n   * @param {number} pa point a\n   * @param {number} pb point b\n   * @param {number} px fractional distance\n   */\n  quadratic(pa, pb, px) {\n    return px < 0.5 ? 2 * px ** 2 * (pb - pa) + pa : (-1 + (4 - 2 * px) * px) * (pb - pa) + pa;\n  }\n\n  /**\n   * Linearly interpolate between 2 points\n   * @param {number} pa point a\n   * @param {number} pb point b\n   * @param {number} px fractional distance\n   */\n  linear(pa, pb, px) {\n    return pa + (pb - pa) * px;\n  }\n\n  /**\n   * Regenerate rows array\n   */\n  randomise(seed = ~~(Math.random() * (2 ** 31 - 1))) {\n    const rand = new PRNG(seed);\n    const d = this.dimension;\n\n    this.rows = Array(this.height).fill(0).map(\n      () => {\n        if (d > 1) {\n          return Array(this.width).fill(0).map(() => {\n            if (d > 2) {\n              return Array(this.depth).fill(0).map(() => rand.generate() * this.amplitude);\n            }\n            return rand.generate() * this.amplitude;\n          });\n        }\n        return rand.generate() * this.amplitude;\n      },\n    );\n  }\n\n  /**\n   * Generate a point in 2d noise\n   * @param {number} x x position\n   * @param {number} y y position\n   */\n  gen2d(x, y, wavelengthx, wavelengthy) {\n    // const { wavelengthx, wavelengthy } = this;\n\n    const normalisedX = x > (this.width * wavelengthx) - 1 ? x % ((this.width) * wavelengthx) : x;\n    const normalisedY = y > (this.height * wavelengthy) - 1 ? y % ((this.height) * wavelengthy) : y;\n\n    // get node indices from array closest to supplied position\n    const currentNodeX = ~~(normalisedX / wavelengthx);\n    const nextNodeX = ~~(normalisedX / wavelengthx) + 1 < this.width\n      ? ~~(normalisedX / wavelengthx) + 1\n      : 0;\n    const currentNodeY = ~~(normalisedY / wavelengthy);\n    const nextNodeY = ~~(normalisedY / wavelengthy) + 1 < this.height\n      ? ~~(normalisedY / wavelengthy) + 1\n      : 0;\n\n    // y is a node\n    if (y % wavelengthy === 0) {\n      // x is a node\n      if (x % wavelengthx === 0) {\n        return this.rows[currentNodeY][currentNodeX];\n      }\n      // between x nodes\n      return this.interpolate(\n        this.rows[currentNodeY][currentNodeX],\n        this.rows[currentNodeY][nextNodeX],\n        (x % wavelengthx) / wavelengthx,\n      );\n    }\n    // between y nodes\n    if (x % wavelengthx === 0) {\n      // x is a node\n      return this.interpolate(\n        this.rows[currentNodeY][currentNodeX],\n        this.rows[nextNodeY][currentNodeX],\n        (y % wavelengthy) / wavelengthy,\n      );\n    }\n    // between x nodes\n    return this.interpolate(\n      this.interpolate(\n        this.rows[currentNodeY][currentNodeX],\n        this.rows[nextNodeY][currentNodeX],\n        (y % wavelengthy) / wavelengthy,\n      ),\n      this.interpolate(\n        this.rows[currentNodeY][nextNodeX],\n        this.rows[nextNodeY][nextNodeX],\n        (y % wavelengthy) / wavelengthy,\n      ),\n      (x % wavelengthx) / wavelengthx,\n    );\n  }\n\n  /**\n   * Generate a point in 3d noise\n   * @param {number} x x position\n   * @param {number} y y position\n   * @param {number} z z position\n   */\n  gen3d(x, y, z, wavelengthx, wavelengthy, wavelengthz) {\n    // const { wavelengthx, wavelengthy, wavelengthz } = this;\n\n    // normalise coordinate values to points array\n    const normalisedX = x > (this.width * wavelengthx) - 1 ? x % ((this.width) * wavelengthx) : x;\n    const normalisedY = y > (this.height * wavelengthy) - 1 ? y % ((this.height) * wavelengthy) : y;\n    const normalisedZ = z > (this.height * wavelengthz) - 1 ? z % ((this.height) * wavelengthz) : z;\n\n    // get node indices from array closest to supplied position\n    const currentNodeX = ~~(normalisedX / wavelengthx);\n    const nextNodeX = ~~(normalisedX / wavelengthx) + 1 < this.width\n      ? ~~(normalisedX / wavelengthx) + 1\n      : 0;\n    const currentNodeY = ~~(normalisedY / wavelengthy);\n    const nextNodeY = ~~(normalisedY / wavelengthy) + 1 < this.height\n      ? ~~(normalisedY / wavelengthy) + 1\n      : 0;\n    const currentNodeZ = ~~(normalisedZ / wavelengthz);\n    const nextNodeZ = ~~(normalisedZ / wavelengthz) + 1 < this.depth\n      ? ~~(normalisedZ / wavelengthz) + 1\n      : 0;\n\n    // z is a node\n    if (z % wavelengthz === 0) {\n      // y is a node\n      if (y % wavelengthy === 0) {\n        // x is a node\n        if (x % wavelengthx === 0) {\n          return this.rows[currentNodeY][currentNodeX][currentNodeZ];\n        }\n\n        // between x nodes\n        return this.interpolate(\n          this.rows[currentNodeY][currentNodeX][currentNodeZ],\n          this.rows[currentNodeY][nextNodeX][currentNodeZ],\n          (x % wavelengthx) / wavelengthx,\n        );\n      }\n\n      // between y nodes\n      if (x % wavelengthx === 0) {\n        // x is a node\n        return this.interpolate(\n          this.rows[currentNodeY][currentNodeX][currentNodeZ],\n          this.rows[nextNodeY][currentNodeX][currentNodeZ],\n          (y % wavelengthy) / wavelengthy,\n        );\n      }\n\n      // between x nodes\n      return this.interpolate(\n\n        this.interpolate(\n          this.rows[currentNodeY][currentNodeX][currentNodeZ],\n          this.rows[nextNodeY][currentNodeX][currentNodeZ],\n          (y % wavelengthy) / wavelengthy,\n        ),\n\n        this.interpolate(\n          this.rows[currentNodeY][nextNodeX][currentNodeZ],\n          this.rows[nextNodeY][nextNodeX][currentNodeZ],\n          (y % wavelengthy) / wavelengthy,\n        ),\n\n        (x % wavelengthx) / wavelengthx,\n      );\n\n\n      // between z nodes\n    }\n\n    // y is a node\n    if (y % wavelengthy === 0) {\n      // x is a node\n      if (x % wavelengthx === 0) {\n        return this.interpolate(\n          this.rows[currentNodeY][currentNodeX][currentNodeZ],\n          this.rows[currentNodeY][currentNodeX][nextNodeZ],\n          (z % wavelengthz) / wavelengthz,\n        );\n      }\n      // between x nodes\n      return this.interpolate(\n\n        this.interpolate(\n          this.rows[currentNodeY][currentNodeX][currentNodeZ],\n          this.rows[currentNodeY][nextNodeX][currentNodeZ],\n          (x % wavelengthx) / wavelengthx,\n        ),\n\n        this.interpolate(\n          this.rows[currentNodeY][currentNodeX][nextNodeZ],\n          this.rows[currentNodeY][nextNodeX][nextNodeZ],\n          (x % wavelengthx) / wavelengthx,\n        ),\n\n        (z % wavelengthz) / wavelengthz,\n      );\n    }\n    // between y nodes\n    if (x % wavelengthx === 0) {\n      // x is a node\n      return this.interpolate(\n        this.interpolate(\n          this.rows[currentNodeY][currentNodeX][currentNodeZ],\n          this.rows[nextNodeY][currentNodeX][currentNodeZ],\n          (y % wavelengthy) / wavelengthy,\n        ),\n\n        this.interpolate(\n          this.rows[currentNodeY][currentNodeX][nextNodeZ],\n          this.rows[nextNodeY][currentNodeX][nextNodeZ],\n          (y % wavelengthy) / wavelengthy,\n        ),\n\n        (z % wavelengthz) / wavelengthz,\n      );\n    }\n    // between x nodes\n    return this.interpolate(\n\n      this.interpolate(\n        this.interpolate(\n          this.rows[currentNodeY][currentNodeX][currentNodeZ],\n          this.rows[nextNodeY][currentNodeX][currentNodeZ],\n          (y % wavelengthy) / wavelengthy,\n        ),\n        this.interpolate(\n          this.rows[currentNodeY][nextNodeX][currentNodeZ],\n          this.rows[nextNodeY][nextNodeX][currentNodeZ],\n          (y % wavelengthy) / wavelengthy,\n        ),\n        (x % wavelengthx) / wavelengthx,\n      ),\n\n      this.interpolate(\n        this.interpolate(\n          this.rows[currentNodeY][currentNodeX][nextNodeZ],\n          this.rows[nextNodeY][currentNodeX][nextNodeZ],\n          (y % wavelengthy) / wavelengthy,\n        ),\n        this.interpolate(\n          this.rows[currentNodeY][nextNodeX][nextNodeZ],\n          this.rows[nextNodeY][nextNodeX][nextNodeZ],\n          (y % wavelengthy) / wavelengthy,\n        ),\n        (x % wavelengthx) / wavelengthx,\n      ),\n\n      (z % wavelengthz) / wavelengthz,\n    );\n  }\n\n  /**\n   * Generate a point in 2d noise with octaves\n   * @param {number} x x position\n   * @param {number} y y position\n   */\n  generate(x = 0, y = 0) {\n    let ret = 0;\n    let offset = 0;\n\n    // generate each octave and add it\n    for (let i = 0; i < this.octaves; i++) {\n      const amplitude = this.amplitude / this.octaveIndex ** i;\n      const wavelengthx = Math.max(this.wavelengthx / this.octaveIndex ** i, 1);\n      const wavelengthy = Math.max(this.wavelengthy / this.octaveIndex ** i, 1);\n\n      const add = this.gen2d(x, y, wavelengthx, wavelengthy) * amplitude;\n\n      ret += add;\n      offset += 1 / this.octaveIndex ** i;\n      // console.table({ add, ret, offset });\n    }\n\n    return ret / offset;\n  }\n\n  generate3d(x = 0, y = 0, z = 0, pixel = 2) {\n    let ret = 0;\n    let offset = 0;\n\n    // generate each octave and add it\n    for (let i = 0; i < this.octaves; i++) {\n      const amplitude = this.amplitude / this.octaveIndex ** i;\n      const wavelengthx = Math.max(this.wavelengthx / this.octaveIndex ** i, 1);\n      const wavelengthy = Math.max(this.wavelengthy / this.octaveIndex ** i, 1);\n      const wavelengthz = Math.max(this.wavelengthz / this.octaveIndex ** i, 1);\n\n      ret += this.gen3d(x, y, z, wavelengthx, wavelengthy, wavelengthz * pixel * 2, 1) * amplitude;\n      offset += 1 / this.octaveIndex ** i;\n    }\n\n    return ret / offset;\n  }\n}\n"],"sourceRoot":""}